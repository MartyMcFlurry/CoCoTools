CoCoTools is a package that facilitates interaction with the CoCoMac
database and analysis of downloaded data.  To free users from the
slowness and unreliability of the server at www.cocomac.org, CoCoTools
enables storage of CoCoMac query results for all BrainMaps of interest
in a local sqlite database.  Of the procedures within CoCoTools, only
the population of this database is subject to the website's
limitations.

>>> from cocotools.query2db import populate_database

populate_database queries CoCoMac for Mapping and Connectivity data
referring to certain BrainMaps and returns a dict detailing which
queries failed.  (Failures are most often due to the CoCoMac server
hanging.)  The function takes two optional arguments: maps and memory.
maps must be an iterable container of BrainMaps or the path to a file
containing one BrainMap per line; its default value causes queries to
be made for all the maps in the online database.  If memory is set as
True, the local database will be created in RAM and not on disk;
otherwise it is placed in a subdirectory of the directory .cache in
the user's home directory.

>>> failed = populate_database(['PP99', 'PP02'])
Completed 1 map, 0 conn (2 maps requested)
Completed 1 map, 1 conn (2 maps requested)
Completed 2 map, 1 conn (2 maps requested)
Completed 2 map, 2 conn (2 maps requested)
Mapping queries failed for []
Connectivity queries failed for []
>>> failed
{'Connectivity': [], 'Mapping': []}

>>> from os.path import join, exists
>>> from os import environ
>>> db = join(environ['HOME'], '.cache', 'cocotools', 'cocotools.sqlite')
>>> exists(db)
True

The sqlite database stores query results in XML, the format
www.cocomac.org returns.  However, the data are better represented as
a set of NetworkX graphs, as Objective Relational Transformation (ORT;
Stephan et al., 2000) makes use of graph-theoretical techniques.  ORT
is an algorithm that condenses the morasse of incompatible statements
that is CoCoMac into a summary connectivity graph that uses a single,
user-chosen nomenclature from the literature.  The discussion that
follows assumes knowledge of ORT; please refer to Stephan et
al. (2000) and Kotter and Wanke (2005).

A transformation graph is constructed from the downloaded Mapping data
using the TrGraph object, a custom subclass of the NetworkX DiGraph.

>>> from cocotools.db2graph import TrGraph
>>> pfc = TrGraph()

Similar to populate_database, the add_edges_from_bmaps method of
TrGraph can be called without any arguments (defaulting to all maps
available in the local database the default) or with a specified
subset of maps.  TrGraph will raise an error if cocotools.sqlite does
not exist in the expected location.  Maps provided in the call to
TrGraph that are not in the local database will be ignored.

>>> pfc.add_edges_from_bmaps(['PP94', 'CP94', 'W40'])
>>> pfc['CP94-13l']['W40-13']
{'PDC': ['C'], 'RC': ['S']}
>>> pfc['W40-13']['PP94-13']
{'PDC': ['H'], 'RC': ['I']}
>>> pfc['CP94-13l'].has_key('PP94-13')
False
>>> pfc['PP94-13'].has_key('CP94-13l')
False

In the previous example, pfc has an edge with RC=S from CP94-13l to
W40-13 and one with RC=I from W40-13 to PP94-13.  One can deduce that
CP94-13l is smaller than PP94-13; however, pfc lacks edges to this
effect because the literature from which the data were derived lack
explicit statements about this relationship.  The first step of ORT,
available in CoCoTools as the deduce_edges method of TrGraph, adds
missing deducible edges to the transformation graph.

>>> new_edges = pfc.deduce_edges()
